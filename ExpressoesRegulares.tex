% Isto √© um coment√°rio que n√£o ser√° processado. Ele serve apenas
% para fazer anota√ß√µes n√£o inclu√≠das no resultado final. Aten√ß√£o
% ao s√≠mbolo do coment√°rio: porcentagem (%).
%a  primeira linha mostra qual vai zer a formata√ß√£o do documento
% tudo esta entre [] √© opcional e o que est√° entre {} √© obrigat√≥rio
% article especifica que o documento levar√° um  formato de artigo (que obvio)
\documentclass[10pt,a4paper]{article}
% todos os comandos \userpackage s√£o pacotes que est√£o sendo usados 
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
%muda  nome do comando \backslash para \CBarra
\newcommand{\CBarra}{$\backslash$}
\newcommand{\circunflexo}{\textasciicircum}
<<<<<<< HEAD
\newcommand{\aspaE}{\textquotedblleft}
\newcommand{\aspaD}{\textquotedblright}
%Aqui definiremos o que vai acompanhar o titulo, mas atenÁ„o
% apenas daremos as informaÁıes, o titulo na verdade È uma combinaÁ„o de 
% informaÁıes, sendo assim,  quando termos o comando \maketitle ele mostar· o titulo com as informaÁıes dadas
% se n„o dermos o comando n„o ir· mostar titulo algum.
=======
%Aqui definiremos o que vai acompanhar o titulo, mas aten√ß√£o
% apenas daremos as informa√ß√µes, o titulo na verdade √© uma combina√ß√£o de 
% informa√ß√µes, sendo assim,  quando termos o comando \maketitle ele mostar√° o titulo com as informa√ß√µes dadas
% se n√£o dermos o comando n√£o ir√° mostar titulo algum.
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
%titulo do documnento
\title{Express√µes Regulares } 
\date{}
%marca o inicio do documento
\begin{document}
%monta o titulo do documento
%ATEN√á√ÉO para montar o titulo tem que dar esse comnado \maketitle
\maketitle
%INICIA O CABE√áALHO DO DOCUMENTO
\begin{center}
%AUTORES DO DOCUMENTO E INFORMA√á√ïES ADICIONAIS
\author 
{Felipe S. Oliveira Barros; Felipe dos S. Pinheiro; Luciano P. Soares.\\
Centro Universit√°rio da Cidade do Rio de Janeiro, Escola de Ci√™ncias Exatas e Tecnologia, NUPAC - N√∫cleo de Projetos e Pesquisa em Aplica√ß√µes Computacionais,
Metr√¥-Carioca (Esta√ß√£o) - Av. Rio Branco e Largo da Carioca s/n}
\end{center}
\begin{center}
Email: \{felipebarros.ti, felipe0pinheiro, lpsoares\}@gmail.com
\end{center} 
%AQUI ENTRA O NOSSO RESUMO
\begin{abstract}
<<<<<<< HEAD
O processamento de texto È uma atividade muito comum em diversas ·reas de atuaÁ„o, mas principalmente a Financeira (processamento de arquivos banc·rios com diferentes layouts) e a Computacional(criaÁ„o de algoritmos para tratar arquivos texto dos mais diversos tipos) 
\paragraph*{}
Com o aumento da demanda e a necessidade cada vez maior de velocidade e eficiÍncia no processamento textual surgiu uma ferramenta que n„o promete resolver todos os problemas,  mas que pode ser uma verdadeira m„o-na-roda para quem faz esse tipo de trabalho, s„o as Expressıes Regulares, RegEx, ou apenas ER.
\paragraph*{}
Expressıes Regulares tem sido uma ferramenta eficiente para identificar caracteres particulares, palavras, subgrupo de caracteres e/ou combinaÁıes destes dentro de um texto. Expressıes mais elaboradas s„o de difÌcil compreens„o para quem est· comeÁando a lidar com elas, mas utiliz·-las È de suma import‚ncia para quem quer reduzir  consideravelmente as linhas de cÛdigo produzidas ou o tempo gasto com processamento de arquivos .txt, csv ou qualquer outro formato de arquivo cujo conte˙do possa ser exibido em texto.
\paragraph*{}
ER's s„o escritas em uma linguagem formal, s„o compostas por sÌmbolos e caracteres com funÁıes especiais que agrupados entre si e com caracteres literais formam uma express„o.  S„o interpretadas por um processador de express„o regular, que analisa o texto e identifica as partes que \aspaE casam\aspaD \space, ou seja, obedecem exatamente a todas as condiÁıes  da express„o fornecida. [1]
\paragraph*{}
O assunto ER È muito extenso, assim como o seu imenso leque de utilidades. Este artigo tem como objetivo introduzir alguns conceitos b·sicos dobre RegEx e a criaÁ„o de uma ferramenta utilizando as linguagens PHP, JavaScript e HTML para a construÁ„o de Expressıes Regulares b·sicas. O p˙blico-alvo para a utilizaÁ„o do sistema È de pessoas que ainda n„o dominem o assunto, mas poder„o com ele criar expressıes b·sicas com apenas alguns cliques.

=======
Na √°rea de Ci√™ncia da Computa√ß√£o express√£o regular tem sido uma t√©cnica eficiente para identificar caracteres particulares ou palavras e at√© mesmo um subgrupo de caracteres. Nem sempre de compreens√£o f√°cil, as express√µes regulares s√£o uma forte ferramenta para o profissional que as manipulam podendo reduzir linhas de c√≥digos e reduzir o tempo gasto no desenvolvimento. Express√µes regulares s√£o escritas numa linguagem formal sendo interpretada por um processador de express√£o regular, este vai analisar o texto e identificar as partes que casam com a express√£o fornecida. O objetivo deste artigo √© prop√µe uma ferramenta para o desenvolvimento de um sistema que constr√≥i uma express√£o regular b√°sica para uma pessoa que n√£o tenha intimidade ou desconhe√ßa esta t√©cnica.
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
\end{abstract}
%AQUI ENTRA O NOSSO RESUMO EM INGL√äS
\begin{center}
\bf{Abstract:}
\end{center}
<<<<<<< HEAD
%\begin{center}
Word processing is a very common several areas, but mainly the Financial (banking with file processing different layouts) and Computer (creation of algorithms to handle text files from various types)
\paragraph*{}
With increasing demand and growing need speed and efficiency in processing textual
came a tool that does not promise to solve all problems, but can be a real hands-on wheel
for those who make this kind of work, are the expressions Regular, RegEx, or only ER.
\paragraph*{}
Regular Expressions has been an effective tool to identify particular characters, words,
subset of characters and / or combinations of these within a text.†More elaborate expressions are difficult to understanding for those just starting to deal with them, but using them is of paramount importance to anyone considerably reduce the lines of code produced or time spent on processing files. txt, csv or any other format file whose contents can be displayed in text.
\paragraph*{}
ER's are written in a formal language, are composed by symbols and characters with special functions that grouped together and form a literal characters expression.†Are interpreted by a processor regular expression, which examines text and identifies
shares that "match", ie, obey exactly all the conditions of the given expression.†[1]
\paragraph*{}
The subject is very extensive ER, as well as its immense range of uses.†This article aims to introduce some basic concepts and double RegEx creating a tool using the PHP,
JavaScript and HTML to build Expressions Regular basic.†The target audience for the use of system is the people who have not mastered the subject, but with it may create with only basic expressions a few clicks
%\end{center}
%INICIO DA SE«√O 1 - IntroduÁ„o
\section{IntroduÁ„o}
\paragraph*{}
A histÛria das expressıes regulares tem origem nas ideias do matem·tico Stephen Cole Kleene (Hartford, 5 de janeiro de 1909 \textendash Madison, 25 de janeiro de 1994 [2]) que, utilizando uma notaÁ„o matem·tica prÛpria chamada de "conjuntos regulares" para descrever modelos de computaÁ„o( autÙmatos finitos ), foi o criador da Algebra Kleene e das Expressıes Regulares.
\paragraph*{}
 N„o existe uma definiÁ„o formal sobre o que seria uma express„o regular, t„o pouco um padr„o de texto que pode ser qualificado ou n„o como express„o regular.
\paragraph*{}
As expressıes regulares ajudam a reduzir a um valor mÌnimo as linhas de cÛdigo em implementaÁıes que trabalham com texto. Atualmente s„o usadas para buscar e/ou substituir, dentro de uma string, uma cadeia de caracteres especifica, mas tambÈm pode ser utilizado para buscar e validar datas, hor·rios, endereÁos IP e MAC, endereÁos de e-mail, etc [1] sendo usados n„o apenas por programadores, mas tambÈm por qualquer prossional que trabalhe diretamente com textos. 
\paragraph*{}
O n˙mero de ferramentas que possibilitam o uso de expressıes regulares È cada fez maior. Entre as mais
conhecidas podemos citar BrOffice, NotePad++, GoogleDocs , Ed, vi e vim. Vale lembrar que nem todas as ferramentas implementem a mesma vers„o de RegEx, ou implementem versıes incompletas, onde um ou outro metacaracter ou caracter especial n„o È reconhecido, por isso vale a pena dar uma olhada na documentaÁ„o da ferramenta com qual deseja trabalhar com RegEx, afim de aproveitar ao m·ximo os recursos disponÌveis.
\paragraph*{}
O objetivo deste artigo È introduzir RegEx e apresentar uma ferramenta online para criaÁ„o de Expressıes Regulares b·sicas, com foco em iniciantes e pessoas que n„o dominam o assunto mas desejam aprender como otimizar seu trabalho. 
\paragraph*{}
A seÁ„o 2 descreve o que È preciso(quais os sÌmbolos e convenÁıes usar) para se criar uma ER, utilizando exemplos simples. Trata-se de um assunto extenso, porÈm extremamente necess·rio para a compreens„o das ER's criadas com o sistema desenvolvido aqui, ou qualquer outro.
\paragraph*{}
A seÁ„o 3 fala tecnicamente do Online RegEx Build Assistant, desde a lÛgica utilizada na implementaÁ„o atÈ exemplos pr·ticos de criaÁ„o de Expressıes.
\paragraph*{}
Na seÁ„o 4, finalmente utilizamos as expressıes geradas em nosso Assistente para resolver problemas reais e comparar resoluÁıes com RegEx e soluÁıes tradicionais.

%INICIO DO ITEM 2 - Conceitos b·scicos
\section{Conceitos b·sicos}
\paragraph*{}
Na inform·tica, o tempo que se leva para processar uma informaÁ„o È muito valioso e as expressıes regulares nos possibilitam resultados r·pidos e precisos. 
\paragraph*{}
Podemos us·-las para procurar textos especÌficos, partes de textos, textos no inicio ou no fim de uma linha, textos com uma seq¸Íncia especifica de caractere, etc.
\paragraph*{}
Ao utilizarmos uma ER procuramos por um padr„o que \aspaE case\aspaD \space com o padr„o especificado. O termo casar dentro de ER quer dizer combinar, e trata-se da idÈia central das ER, pois sempre estamos procurando por uma string que case com as informaÁıes fornecidas.
\paragraph*{}
Para fazer uso das ER utilizamos uma combinaÁ„o de sÌmbolos que chamamos de metacaracteres. Cada metacaracter tem a sua funÁ„o especÌfica no momento de casar uma ER. Os metacaracteres s„o dividdos de acordo com a sua funÁ„o, que s„o:

=======
\begin{center}
TEXTO EM INGLES DO AZULAY....
\end{center}
%INICIO DA SE√á√ÉO 1 - Introdu√ß√£o
\section{Introdu√ß√£o}
\paragraph*{} A hist√≥ria das express√µes regulares (tamb√©m conhecidas como ReGex ou ER) originou-se das ideias do matem√°tico Stephen Cole Kleene,  o respons√°vel por integrar as express√µes regulares e a teoria da computa√ß√£o fazendo uso de aut√¥mato finitos.
\paragraph*{} N√£o existe uma defini√ß√£o formal sobre o que seria uma express√£o regular, t√£o pouco um padr√£o de texto que pode ser qualificado ou n√£o como express√£o regular.
\paragraph*{}
 As express√µes regulares ajudam a reduzir a um valor m√≠nimo as linhas de c√≥digos. Atualmente s√£o usadas para buscar ou substituir, dentro de uma string, uma cadeia de caracteres especifica, mas tamb√©m pode ser utilizado para buscar e validar data, hor√°rio, n√∫mero IP, endere√ßo de e-mail, etc [1] sendo usados n√£o apenas por programadores, mas tamb√©m por qualquer profissional que trabalhe diretamente com textos. Atualmente o numero de ferramentas que possibilitam o uso de express√µes regulares √© cada fez maior entre as ferramentas mais conhecidas podemos citar BrOffice, NotePad++, GoogleDocs , Ed, vi e vim.
\paragraph*{}
O objetivo deste artigo √© mostrar a elabora√ß√£o de um sistema, na linguagem PHP, que auxilie na cria√ß√£o de ER para iniciantes e pessoas que n√£o conhecem o assunto mas desejam otimizar seu trabalho. A se√ß√£o 2 descreve os conhecimentos utilizados para a cria√ß√£o de uma ER utilizando exemplos simples apenas para entendimento de uma express√£o regular, tratasse de um assunto extenso mais extremamente necess√°rio para a elabora√ß√£o do sistema, que ser√° a base de conhecimento utilizado na cria√ß√£o do software. A se√ß√£o 3 descreve a elabora√ß√£o do RegEx Build Assistent.A se√ß√£o 4 mostra uma compara√ß√£o de algoritmos tradicionais, nas linguagens C \# e javascript, e algoritmos utilizando express√µes regulares e tambem a experiencias de usu√°rios com o sistema.
%INICIO DO ITEM 2 - Conceitos b√°scicos
\section{Conceitos b√°sicos}
\paragraph*{}
Na inform√°tica, o tempo que se leva para processar uma informa√ß√£o √© muito valioso e as express√µes regulares nos possibilitam resultados r√°pidos e precisos. Podemos usar as express√µes regulares para procurar textos espec√≠ficos, partes de textos, textos no inicio ou no fim de uma linha ou procurar textos com uma seq√º√™ncia de especifica de caractere.
\paragraph*{}
Ao utilizarmos uma ER procuramos por um padr√£o que case com o padr√£o especificado. O termo casar dentro de ER quer dizer combinar, e trata-se da id√©ia central das ER, pois sempre estamos procurando por uma string que case com as informa√ß√µes fornecidas.
\paragraph*{}
Para fazer uso das ER utilizamos uma combina√ß√£o de s√≠mbolos o qual chamamos de metacaracteres. Cada metacaracter tem a sua fun√ß√£o espec√≠fica no momento de casar uma ER. Os metacaracteres, de acordo com a fun√ß√£o, os que estudaremos est√£o divididos em:
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
\begin{itemize}
\item  Metacaracter tipo Representante;
\item 	Metacaracter tipo Quantificador; e
\item 	Metacaracter tipo Ancora.
\end{itemize}
<<<<<<< HEAD
Existem outros tipos de metacaracteres, os estendidos, porÈm os 3 tipos citados acima s„o suficientes para escrever uma express„o regular b·sica e para a implementaÁ„o do Assistente. 
Na inform·tica, o tempo que se leva para processar uma informaÁ„o È muito valioso e as expressıes regulares nos possibilitam resultados r·pidos e precisos. 

Podemos us·-las para procurar textos especÌficos, partes de textos, textos no inicio ou no fim de uma linha, textos com uma seq¸Íncia especifica de caractere, etc.

\subsection{Metacaracter tipo Representante}
\paragraph*{}
O metacaracter do tipo Representante representa um ou mais caracteres, contudo
representam apenas uma posiÁ„o.
\subsubsection{O metacaracter ponto (.)}
\paragraph*{}
O metacaracter ponto (.), representa um ˙nico caractere, podendo casar com qualquer numero ou letra, inclusive o prÛprio ponto, na posiÁ„o na qual ele foi colocado. Exemplos:\newline
Tarefa: Procurar em um texto qualquer caracter que esteja entre aspas duplas.\newline
SoluÁ„o: "."\newline
Tarefa: Procurar em um texo qualquer caracter entre aspas simples.\newline
SoluÁ„o: '.'\newline
=======
Existem outros tipos de metacaracteres, os estendido, mas somente esses tr√™s tipos de metacaracteres s√£o suficientes para escrevermos uma express√£o regular b√°sica e √© suficiente para a implementa√ß√£o do software. As sintaxes dos metacacteres tamb√©m podem variar de um programa para o outro.
\subsection{Metacaracter tipo Representante}
\paragraph*{}
O metacaracter do tipo Representante representa um ou mais caractere, contudo representam apenas uma posi√ß√£o de caractere.
\subsubsection{O metacaracter ponto (.)}
\paragraph*{}
O metacaracter ponto (.), representa um √∫nico caractere, podendo casar com qualquer numero ou letra, inclusive o pr√≥prio ponto, na posi√ß√£o na qual ele foi colocado.\\
Exemplo:\\
Procurar em texto qualquer caracter que esteja entre as duplas.\newline
Solu√ß√£o: "."\newline
Procurar em um texo qualquer caracter entre aspas simples.\newline
Solu√ß√£o: '.'\newline
\\
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
\subsubsection{O metacaracter lista ([])}
\paragraph*{} O metacaracter lista ([ ]), representa uma lista de argumentos que s„o permitidos no momento da junÁ„o, ou seja, o caracter que est· sendo procurando naquela posiÁ„o sÛ ser· retornado na busca se estiver dentro dos colchetes. Ela torna-se mais eciente que o ponto, pois ela n„o aceita qualquer argumento, somente os especificados. \newline
Exemplos:\newline
Podemos utilizar esse recurso para encontrar palavras com uma possÌvel grafia incorreta ou quando n„o se sabe se est· comeÁando em maiuscula ou minuscula.  A ER <n[„a]o> procura pela string \aspaE n„o\aspaD \space ou \aspaE nao\aspaD \space, <[Nn]„o> casa \aspaE N„o\aspaD \space e \aspaE n„o\aspaD \space.
\paragraph*{}
<<<<<<< HEAD
Se for preciso buscar um valor numÈrico entre 1 e 9 podemos usar a lista <[123456789]>,ou ent„o  <[1-9]> (muito mais cÙmodo). O sÌmbolo \aspaE \textendash \aspaD \space neste caso representa um intervalo, que tambÈm consegue indicar intervalo no alfabeto somente mai˙sculo <[A-Z]> ou somente min˙sculo <[a-z]>, isso n„o inclui as vogais acentuadas, \aspaE «\aspaD \space e \aspaE Á\aspaD \space. Se eu quiser uma lista com letras mai˙sculas, min˙sculas e n˙meros uma das maneiras È usar a ER <[A-Za-z0-9]>.
\paragraph*{}
Vale esclarecer que tudo o que estiver dentro dos colchetes ser· exatamente o que estiver dentro dos colchetes exceto o \aspaE \textendash \aspaD \space que ir· representar o intervalo, quando estiver entre dois caracteres. Dessa maneira a ER [.] vai representar apenas um ponto. Para representar o \aspaE -\aspaD \space dentro da lista devemos coloc·-lo como ultimo item da, ou seja, fora do seu lugar padr„o como caracter especial, entre dois valores.
\paragraph*{}
Como a gram·tica da lÌngua Portuguesa e algumas outras necessitam de caracteres acentuados È possÌvel fazer uso de caracteres especiais chamados de POSIX. Como na lista [A-Za-z] n„o est„o inclusos os caracteres acentuados, È possÌvel substitui-la pela classe[:upper:] (os colchetes fazem parte da classe), que inclui os caracteres acentuados bem como o \aspaE «\aspaD \space e o \aspaE Á\aspaD \space.\newline
=======
O metacaracter lista ([]), representa uma lista de argumentos que s√£o permitidos no momento da jun√ß√£o, ou seja, a string que est√° sendo procurada somente poder√° conter os argumentos que estiverem dentro dos colchetes. Ela torna-se mais eficiente que o ponto, pois ela n√£o aceita qualquer argumento, somente os especificados dentro dos colchetes.
Exemplos: 
\paragraph*{}
Podemos utilizar esse recurso para encontrar palavras com uma poss√≠vel grafia errada. Na ER n[√£a]o procura pela string n√£o ou nao. 
Conseguimos inclusive procurar caracteres escritos mai√∫sculos e min√∫sculos, na ER [Nn]√£o podemos encontrar as strings N√£o e n√£o.
\paragraph*{}
Se necessitarmos procurar um valor num√©rico entre 1 e 9 o correto √© usar a ER [1-9] para representar o intervalo num√©rico pois e bem mais c√¥modo digitar [1-9] do que [123456789]. Podemos representar o intervalo do alfabeto somente mai√∫sculo [A-Z] ou somente min√∫sculo [a-z] isso n√£o inclui as vogais acentuadas, √á e o √ß. Se eu quiser uma lista com letras mai√∫sculas, min√∫sculas e n√∫meros uma das maneiras √© usar a ER [A-Za-z0-9].
\paragraph*{}
Vale esclarecer que tudo o que estiver dentro dos colchetes ser√° exatamente o que estiver dentro dos colchetes exceto o "-" que ir√° representar o intervalo, quando estiver entre dois caracteres. Dessa maneira a ER [.] vai representar apenas um ponto e n√£o vai representar uma lista de qualquer coisa (existe realmente uma maneira de representar isso que ser√° visto mais adiante). Para representar o "-" devemos coloc√°-lo como ultimo item da lista ou seja fora do seu lugar padr√£o.
\paragraph*{}
Nosso idioma necessita de caracteres acentuados em muitas palavras por isso fazemos uso de caracteres especiais chamados de caracteres POSIX. Na lista [A-Za-z] n√£o est√£o inclusos os caracteres acentuados para isso utilizamos a classe [:upper:] (os par√™nteses fazem parte da classe), que inclui os caracteres acentuados bem como o √á e o √ß , nessa situa√ß√£o somente os mai√∫sculos segue uma tabela que mostra a classe POSIX uma lista equivalente e o seu significado. \newline
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%CENTRALIZA E DEPOIS INICIA A TABELA%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin {center}
\begin{tabular}{|l|r|c|} \hline 
classe POSIX & SIMILAR & SIGNIFICA \\ \hline 
[:upper:] & [A-Z] & letras mai√∫sculas \\ \hline
[:lower:] & [a-z] & letras min√∫sculas \\ \hline
[:alpha:] & [A-Za-z] & mai√∫sculas/min√∫sculas \\ \hline
[:alnum:] & [A-Za-z0-9] & letras e n√∫meros \\ \hline
[:digit:] & [0-9] & n√∫meros \\ \hline
[:xdigit:] & [0-9A-a-f] & n√∫meros hexadecimais \\ \hline
[:punct:] & [.,!?:...] & sinais de pontua√ß√£o \\ \hline
[:blank:] & [\CBarra t] & espa√ßo e TAB \\ \hline
[:space:] & [\CBarra t, \CBarra n, \CBarra r, \CBarra f, \CBarra v] & caracteres brancos \\ \hline
[:cntrl:] & - & caracteres de controle \\ \hline
[:graph:] & [\textasciicircum \CBarra t,\CBarra n,\CBarra r, \CBarra f, \CBarra v] & caracteres imprim√≠veis \\ \hline
[:print:] & [\textasciicircum ,\CBarra t,\CBarra n, \CBarra r,\CBarra f, \CBarra v] & imprim√≠veis e o espa√ßo \\ \hline
\end{tabular} \\ 
Figura 1 - Tabela de classes P√íSIX
\end {center}
%termino da tabela
\subsubsection{O metacaracter lista negada ([\textasciicircum ...])}
\paragraph*{}
<<<<<<< HEAD
O metacaracter lista negada ([\circunflexo ...]) possui a mesma sintaxe da lista, aceita intervalos liter·rios, numÈricos e classes Posix, mas o seu signicado È inverso. O que est· fora da lista È aceito e o que est· dentro n„o, ou seja, na ER <[\circunflexo 0-9]> seria aceito qualquer caractere exceto n˙meros. …possÌvel tambÈm excluir o alfabeto min˙sculo ou mai˙sculo com as ER's <[\circunflexo a-z]> e <[\circunflexo A-Z]> respectivamente ou usar as classes POSIX's <[\circunflexo [:lower:]]> e <[\circunflexo[:upper:]]> .
\subsection{Metacaracteres Quanticadores}
Os metacaracteres do tipo quantificador dizem quantas vezes um determinado
caractere ou matacaracter pode aparecer na string. Esse tipo de metacaracter
È conhecido como guloso, pois se for usado permitindo uma repetiÁ„o, ele tentar· usar o numero m·ximo de repetiÁıes possÌveis.
\subsubsection{O Metacaracter Opcional ( ?)}
\paragraph*{}
Muito ˙til para procurar palavras no singular e no plural, o metacaracter
opcional (?) È usado quando queremos a ocorrÍncia de 0 ou 1 caractere, somente
para o caractere marcado e n„o para a palavra toda. \newline 
Exemplo:
=======
O metacaracter lista negada ([\circunflexo ...]) possui a mesma sintaxe da lista, aceita intervalos liter√°rios, num√©ricos e classes Posix, mas o seu significado √© inverso. Quando usamos a lista negada queremos dizer que est√° fora da lista √© aceito e o que est√° dentro n√£o, ou seja, na ER [\circunflexo 0-9] seria aceito qualquer caractere exceto n√∫mero, mas sempre haver√° um retorno. Podemos tamb√©m excluir o alfabeto min√∫sculo ou mai√∫sculo com as ER's [\circunflexo a-z] e [\circunflexo A-Z] respectivamente ou usar as classes POSIX's  [\circunflexo[:lower:] ]e [\circunflexo[:upper:]] .
\subsection{ Metacaracteres Quantificadores}
\paragraph*{}
Os metacaracteres do tipo quantificador dizem quantas vezes um determinado caractere ou matacaracter pode aparecer na string. Esse tipo de metacaracter √© dito gulosos, pois se for usado permitindo uma repeti√ß√£o, ele tentar√° usar o numero m√°ximo de repeti√ß√µes poss√≠veis. 
\subsubsection{O Metacaracter Opcional ( ?)}
\paragraph*{}
Muito √∫til para procurar palavras no singular e no plural, o metacaracter opcional (?) √© usado quando queremos a ocorr√™ncia de 0 ou 1 caractere, somente para o caractere marcado e n√£o para a palvra toda.Podemos, com os conceitos j√° vistos, implementar uma lista opcional como segue abaixo.
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
\begin{itemize}
\item <festas?> retorna  ou \aspaE festa \aspaD \space \aspaE festas \aspaD \space pois o "s" foi marcado como opcional.
\item <fala[r!]?> retona \aspaE falar\aspaD \space, \aspaE fala\aspaD \space e \aspaE fala\aspaD \space.
\item <1581?8> retorna \aspaE 1581\aspaD \space ou \aspaE 1588\aspaD \space\space pois o \aspaE 1\aspaD \space \space foi marcado como opcional.
\end{itemize}
\subsubsection{O Metacaracter Asterisco (*)}
\paragraph*{}
<<<<<<< HEAD
O metacaracter asterisco permite o caractere aparecer nenhuma vez ou em
uma quantidade infinita de vezes.\\
=======
O metacaracter asterisco permite o caractere aparecer nenhuma vez ou em uma quantidade infinita de v√™zes.\\
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
Exemplos:
\begin{itemize}
\item <6*0> retorna \aspaE 0\aspaD, \aspaE 60\aspaD, \aspaE 660\aspaD, \aspaE 6660\aspaD, \aspaE 66660\aspaD, ..., \aspaE 66666666666666660 \aspaD,...
\item <b[ip]*> retorna \aspaE b\aspaD, \aspaE bi\aspaD, \aspaE bii\aspaD, \aspaE bip\aspaD, \aspaE biipp\aspaD, \aspaE bpi\aspaD, \aspaE bppii\aspaD............
\end{itemize}
<<<<<<< HEAD
Ao utilizar a combinaÁ„o do \aspaE.\aspaD e do \aspaE *\aspaD, ou seja  \aspaE.*\aspaD que retornar qualquer coisa em qualquer quantidade.
\subsubsection{Metacaracter Mais (+)}
\paragraph*{}
Semelhante ao asterisco o mais (+) diferencia-se em um ˙nico ponto, o caracter deve aparecer pelo menos uma vez, no asterisco ele n„o precisava aparecer. ⁄til quando queremos no mÌnimo uma apariÁ„o. Usando os mesmos exemplos do metacaracter asterisco podemos perceber que \aspaE 0\aspaD \space sozinho n„o È retornado e que  \aspaE b \aspaD \space sozinho tambÈm n„o:
=======
Podemos utilizar a combina√ß√£o do . e o * obtendo dessa maneira a ER .* que ir√° retornar qualquer coisa em qualquer quantidade.
\subsubsection{Metacaracter Mais (+)}
\paragraph*{}
Semelhante ao asterisco o mais (+)  diferencia-se em um √∫nico ponto, o caracter deve aparecer pelo menos uma vez, no asterisco ele n√£o precisava aparecer, √∫til quando queremos no m√≠nimo uma apari√ß√£o. Usando os mesmos exemplos do metacaracter asterisco podemos perceber que a string 0 sozinha n√£o √© retornada e que b sozinho tamb√©m n√£o:
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
\begin{itemize}
\item <6+0> retorna \aspaE 60\aspaD, \aspaE 660\aspaD, \aspaE 6660\aspaD, \aspaE 66660\aspaD, ..., \aspaE 66666666666666660 \aspaD,...
\item <b[ip]+> retorna \aspaE bi\aspaD, \aspaE bii\aspaD, \aspaE bip\aspaD, \aspaE biipp\aspaD, \aspaE bpi\aspaD, \aspaE bppii\aspaD............
\end{itemize}
\subsubsection {O Metacaracter chaves (\{\})}
\paragraph*{}
<<<<<<< HEAD
O metacaracter chaves ( { } ) È usado para especificar quantas repetiÁıes de cada caractere queremos ter. Se escrevermos {a,b} queremos dizer algo de a atÈ b. Exemplo:\newline
=======
O metacaractere chaves ( \{\} ) √© usado para especificar quantas repeti√ß√µes de cada caractere queremos ter. Se escrevermos \{a,b\}  queremos dizer algo de a at√© b\\
Exemplo:
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
\begin{itemize}
\item <\{1,9\}> retorna "9", "99", "999", "9999", "99999",... e "999999999".
\end{itemize}
<<<<<<< HEAD
Partindo dessa armaÁ„o podemos perceber que È possÌvel uma substituiÁ„o da
combinaÁ„o de chaves pelos metacaracteres asterisco, opcional e mais.
\subsection{Metacaracteres ¬ncora}
\paragraph*{}
Esse tipo de metacaracter n„o faz junÁ„o de outro caractere ou determinauma
quantidade, ele marca uma posiÁ„o especifica na linha. Por causa da funÁ„o que
exerce, o metacaracter n„o pode ser quanticado, ou seja, os metacaracteres
asterisco, mais e opcional n„o exercem influÍncia sobre estes.
\subsubsection{O metacaracter Circunflexo (\circunflexo)}
\paragraph*{}
Indica que estamos procurando por algo no comeÁo da linha. … possÌvel combinar a lista negada com o circunexo.\newline
Exemplo:
\begin{itemize}
\item <\circunflexo[0-9]> indica que estamos procurando linhas que comeÁam com n˙meros.n˙meros.\\
\item <\circunflexo [\circunflexo a-z]> indica as linhas que n„o comeÁam com letra min˙scula.
=======
Partindo dessa afirma√ß√£o podemos perceber que √© poss√≠vel uma substitui√ß√£o da combina√ß√£o de chaves pelos metacaracteres asterisco, opcional e mais.
\subsection{Metacaracteres √Çncora}
\paragraph*{}
Esse tipo de metacaracter n√£o faz jun√ß√£o de outro caractere ou define uma quantidade, ele marca uma posi√ß√£o especifica na linha. Por causa da fun√ß√£o que exerce, o metacaracter n√£o pode ser quantificado, ou seja, os metacaracteres asterisco, mais e opcional n√£o exercem influ√™ncia sobre estes.
\subsubsection{O metacaracter Circunflexo (\circunflexo)}
\paragraph*{}
Indica que estamos procurando por algo no come√ßo da  linha.\\
√â poss√≠vel combinar a lista negada com o circunflexo.
Exemplo:
\begin{itemize}
\item \circunflexo[0-9] indica que estamos procurando linhas que come√ßam com n√∫meros.\\
\item \circunflexo [\circunflexo a-z] indica as linhas que n√£o come√ßam com letra min√∫scula.
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
\end{itemize}
\subsubsection{O Metacaracter Cifr√£o (\$)}
\paragraph*{}
<<<<<<< HEAD
O metacaracter cifr„o È usado da mesma forma que o circunflexo, mas o cifr„o
indica o fim de uma linha.
Exemplo
\begin{itemize}
\item <[0-9]\$> indica uma linha que termina com n˙meros.
\item <\circunflexo \$> indica uma linha vazia.
\item <..... \$> indica uma linha que termine com 5 caracteres.
\item <\circunflexo .10,50\$> indica linhas que tenham entre 10 e 50 caracteres.
\end{itemize}
\subsubsection{O metacaracter borda ( \CBarra b )}
\paragraph*{}
O metacaracter borda (\CBarra b ) marca o inicio onde a palavra inicia ou onde ela termina, ou ainda os dois simultaneamente, ˙til para encontrar palavras exatas e n„o parciais. A seguir um exemplo do comportamento da ER com a palavra
dia [1].
=======
O metacaracter cifr√£o √© usado da mesma forma que o circunflexo, mas o cifr√£o indica o fim de uma linha.\\
Exemplo
\begin{itemize}
\item [0-9]\$ indica uma linha que termina com n√∫meros.
\item \circunflexo \$ indica  uma linha vazia
\item ..... \$ indica uma linha que termine com 5 caracteres
\item \circunflexo.{10,50}\$ indica linhas que tenham entre 10 e 50 caracteres.
\end{itemize}
\subsubsection{O metacaracter borda ( \CBarra b )}
\paragraph*{}
O metacaracter borda (\CBarra b ) marca o inicio onde a palavra inicia ou onde ela termina, ou ainda os dois simultaneamente, √∫til para encontrar palavras exatas e n√£o parciais. A seguir um exemplo do comportamento da ER com a palavra dia [1].
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
\begin{itemize}
\item <dia> retorna "dia", "diafragma", "radial", "melodia", "bom-dia"!
\item <\CBarra bdia> retorna "dia", "diafragma".
\item <dia\CBarra b> retorna "dia", "melodia", "bom-dia!"

\item <\CBarra bdia\CBarra b> retorna "dia".
\end{itemize}
\subsection{Metaceracteres Extendidos.}
\paragraph*{}
<<<<<<< HEAD
Existem metacarecteres que n„o possuem uma especicaÁ„o relacionada com
os anteriores por isso s„o denominados metacaracteres extendidos[1] e s„o amplamente usados para facilitar escrita de uma ER.
\subsubsection{O Metacaracter Escape (\CBarra )}
\paragraph*{}
Se quisermos representar um matacaracter na forma literal, podemos fazÍ-lo
atravÈs de uma lista. No entanto a lista È mais adequada para representar
um conjunto de caracteres. Nesse caso a soluÁ„o mais vi·vel seria o uso do
metacaracter escape.\newline
Tarefa: Representar atravÈs de uma ER um numero de CPF no formato xxx.xxx.xxx-xx
=======
Existem metacarecteres que n√£o possuem uma especifica√ß√£o relacionada com os anteriores por isso s√£o denominados metacaracteres extendidos[1] e s√£o amplamente usados para facilitar escrita de uma ER.
\subsubsection{O Metacaracter Escape (\CBarra )}
\paragraph*{}
Se quisermos representar um matacaracter na forma literal, podemos faze-lo atrav√©s de uma lista. No entanto a lista √© mais adeguado para representar um conjunto de caracteres. Nesse caso a solu√ß√£o mais vi√°vel seria o uso do metacaracter escape.\\
Exemplo: Representar atraves de uma ER um numero de CPF no formato xxx.xxx.xxx-xx
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
\begin{itemize}
\item
<[0-9]\{1,3\}\CBarra.[0-9]\{1,3\}\CBarra.[0-9]\{1,3\}-[0-9]\{1,2\}>
\end{itemize}
\subsubsection{O Metacaracter grupo "()"}
\paragraph*{}
<<<<<<< HEAD
O metacaracter grupo "()" È muito utilizado para agrupar outros metacaracteres, caracteres e subgrupos tornando seu uso essecial para simplicar uma express„o regular. Todo o conteudo que estiver entre parenteses ser· identicado como um grupo, e este dever· casar dentro da RegEx.\newline
=======
O metacaracter grupo "()" ¬¥√© muito utilizado para agrupar outros metacaractes, caracteres e subgrupos tornando seu uso essecial para simplificar uma express√£o regular. Todo o conteudo que estiver entre parenteses ser√° identificado como um grupo, e este dever√° casar dentro da regex.\newline
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
Exemplos:\newline
<(www\.)?google.com(\.br)> retorna www.google.com.br, www.google.com, google.com e google.com.br
\subsubsection{O Metacaracter OU (|)}
\paragraph*{}
<<<<<<< HEAD
O metacaracter OU (|) funciona como um operador booleano, possibilitando
alternativas diversas para a express„o, ao us·-lo podemos casar todas estas
possibilidades, usando o metacaracter "( )"tornamos o ou"( | ) mais poderoso.
Tarefa: Encontrar endereÁos de internet que sejam https:// ou estilo ftp:// [1].
Resposta: <(http://|ftp://)>
\subsection{PrecedÍncia entre metacaracteres}
\paragraph{}
Os metacarcteres possuem uma precedÍncia para melhor entendermos e determinamos
uma RegEx.
=======
O metacaracter ou (|) funciona como um operador booleano, possibilitando alternativas diversas para a express√£o, ao us√°-lo podemos casar todas estas possibilidades, usando o metacaracter "()" tornamos o ou" (|) mais poderoso.\newline
Exemplo:\newline
Encontrar endere√ßos de internet que sejam https:// ou estilo ftp:// [1].\newline
(http://|ftp://)
\subsection{Preced√™ncia entre metacaracteres}
\paragraph{}
Os metacarcteres possuem uma preced√™ncia para melhor entendermos e determinamos uma RegEx.A seguir uma tabela que mostra a preced√™ncia entre caracteres baseada no livro de[1].
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
\begin {center}
\begin{tabular}{|l|r|c|} \hline 
Tipo de meta & Exemplo & Proced√™ncia\\ \hline
quantificador & ab+ & maior\\ \hline
concatena√ß√£o & ab & m√©dia\\ \hline
ou & ab|c & menor\\ \hline
\end{tabular} \\ 
Figura 2 - Tabela de proced√™ncia entre os metacaracteres.
\end {center}
<<<<<<< HEAD
Desda forma uma RegEx 12* n„o seria uma RegEx 1 com 2 em qualquer quantidade e sim 1 seguido de 2 em qualquer quantidade.\newline
\section{ O Software Regex Build Assistent}
% NESSA PARTE VAMOS FALAR UM POUCO SOBRE O REGEX BUILD ASSISTENT
%AZULAY??

\section{AvaliaÁ„o da ferramenta}
\paragraph{}
A motivaÁ„o, que levou ao desenvolvimento da ferramenta foi o uso de express„o regular no cÛdigo de programas, no entanto isso nem sempre È possivel devido ao pouco ou nenhum conhecimento por parte dos programadores sobre express„o regular. Dividimos os teste com a ferramentas em duas partes:
\begin{itemize}
\item ComparaÁ„o de um cÛdigos para validar emails com express„o regular e o outro sem express„o regular.
\item Teste de utilizaÁ„o da ferramenta por 3 usu·rios, 1 usu·rio possuia conhecimentos de express„o regular e 2 usuarios sem conhecimentos.
\end{itemize}
\subsection{Validar e-mails em C \#}
\paragraph{}
As funÁıes a seguir s„o usados para validar emails na linguagem C \#:
\begin{itemize}
\item FunÁ„o sem express„o regular:\newline
\newline

 public static bool ValidarEmail(string email) \newline
\{ \newline
\t           bool validEmail = false; \newline
=======
Desda forma uma RegEx 12* n√£o seria uma RegEx 1 com 2 em qualquer quantidade e sim 1 seguido de 2 em qualquer quantidade.\newline
\subsection{ O Software Regex Build Assistent}
% NESSA PARTE VAMOS FALAR UM POUCO SOBRE O REGEX BUILD ASSISTENT
%AZULAY??

\subsection{Avalia√ß√£o da ferramenta}
\paragraph{}
A motiva√ß√£o, que levou ao desenvolvimento da ferramenta foi o uso de express√£o regular no c√≥digo de programas, no entanto isso nem sempre √© possivel devido ao pouco ou nenhum conhecimento por parte dos programadores sobre express√£o regular. Dividimos os teste com a ferramentas em duas partes:
\begin{itemize}
\item Compara√ß√£o de um c√≥digos para validar emails com express√£o regular e o outro sem express√£o regular.
\item Teste de utiliza√ß√£o da ferramenta por 3 usu√°rios, 1 usu√°rio possuia conhecimentos de express√£o regular e 2 usuarios sem conhecimentos.
\end{itemize}
\subsubsection{Validar e-mails em C \#}
\paragraph{}
As fun√ß√µes a seguir s√£o usados para validar emails na linguagem C \#:
\begin{itemize}
\item Fun√ß√£o sem express√£o regular:\newline
\newline
 public static bool ValidarEmail(string email) \newline
\t \{ \newline
		bool validEmail = false; \newline
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
		     int indexArr = email.IndexOf('@'); \newline
		     if (indexArr > 0)\newline
		  \{ \newline
			         int indexDot = email.IndexOf('.', indexArr); \newline
			         if (indexDot - 1 > indexArr) \newline
			      \{ \newline
				            if (indexDot + 1 < email.Length) \newline
					         \{ \newline
					            string indexDot2 = email.Substring(indexDot + 1, 1); \newline
					                 if (indexDot2 != ".") \newline
					               \{ \newline

						                  validEmail = true; \newline

					         \} \newline
				      \} \newline
			   \} \newline
		\} \newline
	\t     return validEmail; \newline
\} \newline

<<<<<<< HEAD
\item FunÁ„o com express„o regular:\newline
=======
\item Fun√ß√£o com express√£o regular:\newline
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
string email = txtEmail.Text; \newline
Regex rg = new Regex (@"\circunflexo[A-Za-z0-9](([\_ \CBarra.\CBarra\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)
(([\CBarra.\CBarra-]?[a-zA-Z0-9]+)*)\CBarra.([A-Za-z]\{2,\})\$");\newline
if (rg.IsMatch( email ) ) \newline
\{\newline
      Response.Write("Email Valido!");\newline
\}\newline
else\newline
\{\newline
<<<<<<< HEAD
      Response.Write("Email Inv·lido!");\newline
=======
      Response.Write("Email Inv√°lido!");\newline
>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
\}\newline

\end{itemize}

<<<<<<< HEAD
=======

>>>>>>> 4250a2c543c8bbce3432737f862a1b6dfd0eee95
\begin{thebibliography}{}
[1]JARGAS, Aur√©lio Marinho. Express√µes Regulares - Uma abordagem divertida. 3 ed. Novatec, 2009.\\

\end{thebibliography}
\end{document}
